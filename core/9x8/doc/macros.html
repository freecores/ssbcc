
<!-- Copyright 2012, Sinclair R.F., Inc. -->
<html>
<title>
macros
</title>
<body>
<h1>Macros for the 9x8 micro controller</h1><br/>
Copyright 2012, Sinclair R.F., Inc.<br/><br/>
This document describes the macros for 9x8 micro controller.<br/><br/>
Macros are used to access opcodes that cannot be used directly or to help
  improve code readability and provide syntax checking for some
  opcodes.<br/><br/>
  <h2>call, callc, jump, and jumpc</h2>
    The unconditional and the conditional call and jump instructions are three
      instruction sequences.  The first instructions pushes the 8&nbsp;lsb of
      the target address onto the stack, the second instruction is the jump or
      call with the 5&nbsp;msb of the target address encoded into the
      instruction, and the third instruction is the instruction that is always
      executed immediately after the jump or call.  Because the first two
      instructions are dependent on the target address a macro is required to
      generate the push and the call or jump instruction.  Also, because the
      instruction immediately after the call or jump is always executed
      immediately after the call or jump it is also generated by the macro.  The
      default value for this third instruction can be changed by including it as
      the optional second argument to the macro.<br/><br/>
  <h2>fetch, fetch+, fetch-, store, store+, and store-</h2>
    The fetch and store instructions required the 2&nbsp;bit memory bank index
      to be encoded as part of the fetch or store instruction.  The memory bank
      is specified by its name.<br/><br/>
    The macros also ensure that the provided symbol is a memory bank
      name.<br/><br/>
  <h2>fetchvalue and storevalue</h2>
    These macros are used read a value from or write a value to memory by
      variable name.  The offset of the variable within the memory bank is
      pushed onto the data stack and the memory bank associated with the
      variable is encoded into the <tt>fetch</tt> or <tt>store</tt> instruction.
      The <tt>storevalue</tt> macro also consumes the top of the data stack by
      adding a third, <tt>drop</tt> instruction.<br/><br/>
    These macros ensure that the provided symbol is a variable name.<br/><br/>
  <h2>fetchvector and storevector</h2>
    These macros are used to generate multi-instructions sequences to transfer
      two or more values between the memory and the data stack.  The storevector
      macro transfers the data stack to memory with the top of the data stack
      stored at the specified variable, the next value stored at the next
      location in memory and so forth.  The fetchvector macro reads the values
      from memory in the reverse order in which they were stored so that the
      fetchvector and storevector macros are inverses of each other.<br/><br/>
    If the MSB of a multi-byte value is stored at the top of the data stack as
      per the Forth convention, then the storevector macro places the MSB at the
      specified variable and the subsequent less significant bytes at subsequent
      locations in memory.<br/><br/>
    These macros ensure that the provided symbol is a variable name.<br/><br/>
  <h2>fetchindexed and storeindex</h2>
    If the top of the data stack is an index into a multi-byte value, these
      macros can be used to fetch or store the associated value from the
      specified variable.  Using the macro ensures the correct memory bank is
      used for the specified variable.<br/><br/>
    These macros ensure that the provided symbol is a variable name.<br/><br/>
  <h2>inport and outport</h2>
    The <tt>inport</tt> and <tt>outport</tt> instructions can be specified
      directly in the assembly file.  However, the code reliability and
      readability can be improved by using the macros.  For example, if the top
      of the data stack is to be output to the specified port and then dropped,
      the macro <tt>.outport(O_NAME)</tt> will generate the required three
      instruction sequence.<br/><br/>
    These macros also ensure that and input port or an output port respectively
      are specified to the macro, thus helping to identify coding
      mistakes.<br/><br/>
  <h2>return</h2>
    Because the instruction immediately following the return instruction is
      executed immediately after the return instruction, a macro is used to
      ensure that the two instruction sequence is properly generated.  The
      default instruction can be changed by providing the optional argument to
      the macro.<br/><br/>
<h1>Macros</h1>
  Alphebetic listing:
    <a href="#.call">.call</a>,
    <a href="#.callc">.callc</a>,
    <a href="#.fetch">.fetch</a>,
    <a href="#.fetch+">.fetch+</a>,
    <a href="#.fetch-">.fetch-</a>,
    <a href="#.fetchindexed">.fetchindexed</a>,
    <a href="#.fetchvalue">.fetchvalue</a>,
    <a href="#.fetchvector">.fetchvector</a>,
    <a href="#.inport">.inport</a>,
    <a href="#.jump">.jump</a>,
    <a href="#.jumpc">.jumpc</a>,
    <a href="#.outport">.outport</a>,
    <a href="#.return">.return</a>,
    <a href="#.store">.store</a>,
    <a href="#.store+">.store+</a>,
    <a href="#.store-">.store-</a>,
    <a href="#.storeindexed">.storeindexed</a>,
    <a href="#.storevalue">.storevalue</a>,
    and <a href="#.storevector">.storevector</a>.<br/><br/>
  <h2><a name=".call">.call</a></h2>
    <b>Description:</b>  Generate the 3 instruction sequence associated with a <tt>call</tt> instruction.<br/><br/>
    <b>Operation(1):</b>  <tt>.call(label)</tt> generates the following 3 instructions:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;push the 8 lsb of the label address onto the data stack<br/>
      &nbsp;&nbsp;2&nbsp;&mdash;&nbsp;call with the 5 msb of the label address encoded in the call instruction<br/>
      &nbsp;&nbsp;3&nbsp;&mdash;&nbsp;no operation<br/><br/>
    <b>Operation(2):</b>  <tt>.call(label,op)</tt> where "op" is an instruction generates the following 3 instructions:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;push the 8 lsb of the label address onto the data stack<br/>
      &nbsp;&nbsp;2&nbsp;&mdash;&nbsp;call with the 5 msb of the label address encoded in the call instruction<br/>
      &nbsp;&nbsp;3&nbsp;&mdash;&nbsp;op<br/><br/>
    Note that Operation(1) is a special case of Operation(2) with "op" being the <tt>nop</tt> instruction.<br/>
  <h2><a name=".callc">.callc</a></h2>
    <b>Description:</b>  Generate the 3 instruction sequence associated with a <tt>callc</tt> instruction.<br/><br/>
    <b>Operation(1):</b>  <tt>.callc(label)</tt> generates the following 3 instructions:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;push the 8 lsb of the label address onto the data stack<br/>
      &nbsp;&nbsp;2&nbsp;&mdash;&nbsp;callc with the 5 msb of the label address encoded in the callc instruction<br/>
      &nbsp;&nbsp;3&nbsp;&mdash;&nbsp;drop<br/><br/>
    <b>Operation(2):</b>  <tt>.callc(label,op)</tt> where "op" is an instruction generates the following 3 instructions:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;push the 8 lsb of the label address onto the data stack<br/>
      &nbsp;&nbsp;2&nbsp;&mdash;&nbsp;callc with the 5 msb of the label address encoded in the callc instruction<br/>
      &nbsp;&nbsp;3&nbsp;&mdash;&nbsp;op<br/><br/>
    Note that Operation(1) is a special case of Operation(2) with "op" being the <tt>drop</tt> instruction.<br/>
  <h2><a name=".fetch">.fetch</a></h2>
    <b>Description:</b>  Generate the <tt>fetch</tt> instruction.<br/><br/>
    <b>Operation:</b>  <tt>.fetch(ram)</tt> generates the following instruction:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;fetch with the 2 bit memory index encoded in the fetch instruction.<br/>
  <h2><a name=".fetch+">.fetch+</a></h2>
    <b>Description:</b>  Generate the <tt>fetch+</tt> instruction.<br/><br/>
    <b>Operation:</b>  <tt>.fetch+(ram)</tt> generates the following instruction:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;fetch+ with the 2 bit memory index encoded in the fetch+ instruction.<br/>
  <h2><a name=".fetch-">.fetch-</a></h2>
    <b>Description:</b>  Generate the <tt>fetch-</tt> instruction.<br/><br/>
    <b>Operation:</b>  <tt>.fetch-(ram)</tt> generates the following instruction:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;fetch- with the 2 bit memory index encoded in the fetch- instruction.<br/>
  <h2><a name=".fetchindexed">.fetchindexed</a></h2>
    TODO
  <h2><a name=".fetchvalue">.fetchvalue</a></h2>
    TODO
  <h2><a name=".fetchvector">.fetchvector</a></h2>
    TODO
  <h2><a name=".inport">.inport</a></h2>
    <b>Description:</b>  Generate the 2 instruction sequence associated with a <tt>inport</tt> instruction.<br/><br/>
    <b>Operation:</b>  <tt>.inport(label)</tt> generates the following 3 instructions:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;push the 8 lsb of the label address onto the data stack<br/>
      &nbsp;&nbsp;2&nbsp;&mdash;&nbsp;<tt>inport</tt><br/>
  <h2>.jump</h2>
    <b>Description:</b>  Generate the 3 instruction sequence associated with a <tt>jump</tt> instruction.<br/><br/>
    <b>Operation(1):</b>  <tt>.jump(label)</tt> generates the following 3 instructions:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;push the 8 lsb of the label address onto the data stack<br/>
      &nbsp;&nbsp;2&nbsp;&mdash;&nbsp;jump with the 5 msb of the label address encoded in the jump instruction<br/>
      &nbsp;&nbsp;3&nbsp;&mdash;&nbsp;no operation<br/><br/>
    <b>Operation(2):</b>  <tt>.jump(label,op)</tt> where "op" is an instruction generates the following 3 instructions:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;push the 8 lsb of the label address onto the data stack<br/>
      &nbsp;&nbsp;2&nbsp;&mdash;&nbsp;jump with the 5 msb of the label address encoded in the jump instruction<br/>
      &nbsp;&nbsp;3&nbsp;&mdash;&nbsp;op<br/><br/>
    Note that Operation(1) is a special case of Operation(2) with "op" being the <tt>nop</tt> instruction.<br/>
  <h2>.jumpc</h2>
    <b>Description:</b>  Generate the 3 instruction sequence associated with a <tt>jumpc</tt> instruction.<br/><br/>
    <b>Operation(1):</b>  <tt>.jumpc(label)</tt> generates the following 3 instructions:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;push the 8 lsb of the label address onto the data stack<br/>
      &nbsp;&nbsp;2&nbsp;&mdash;&nbsp;jumpc with the 5 msb of the label address encoded in the jumpc instruction<br/>
      &nbsp;&nbsp;3&nbsp;&mdash;&nbsp;drop<br/><br/>
    <b>Operation(2):</b>  <tt>.jumpc(label,op)</tt> where "op" is an instruction generates the following 3 instructions:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;push the 8 lsb of the label address onto the data stack<br/>
      &nbsp;&nbsp;2&nbsp;&mdash;&nbsp;jumpc with the 5 msb of the label address encoded in the jumpc instruction<br/>
      &nbsp;&nbsp;3&nbsp;&mdash;&nbsp;op<br/><br/>
    Note that Operation(1) is a special case of Operation(2) with "op" being the <tt>drop</tt> instruction.<br/>
  <h2><a name=".outport">.outport</a></h2>
    <b>Description:</b>  Generate the 3 instruction sequence associated with a <tt>outport</tt> instruction.<br/><br/>
    <b>Operation(1):</b>  <tt>.outport(label)</tt> generates the following 3 instructions:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;push the 8 lsb of the label address onto the data stack<br/>
      &nbsp;&nbsp;2&nbsp;&mdash;&nbsp;<tt>outport</tt><br/>
      &nbsp;&nbsp;3&nbsp;&mdash;&nbsp;<tt>drop</tt><br/><br/>
    <b>Operation(2):</b>  <tt>.outport(label,op)</tt> generates the following 3 instructions:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;push the 8 lsb of the label address onto the data stack<br/>
      &nbsp;&nbsp;2&nbsp;&mdash;&nbsp;<tt>outport</tt><br/>
      &nbsp;&nbsp;3&nbsp;&mdash;&nbsp;op<br/><br/>
    Note that Operation(1) is a special case of Operation(2) with "op" being the <tt>drop</tt> instruction.<br/>
  <h2><a name=".return">.return</a></h2>
    TODO
  <h2><a name=".store">.store</a></h2>
    <b>Description:</b>  Generate the <tt>store</tt> instruction.<br/><br/>
    <b>Operation:</b>  <tt>.store(ram)</tt> generates the following instruction:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;store with the 2 bit memory index encoded in the store instruction.<br/>
  <h2><a name=".store+">.store+</a></h2>
    <b>Description:</b>  Generate the <tt>store+</tt> instruction.<br/><br/>
    <b>Operation:</b>  <tt>.store+(ram)</tt> generates the following instruction:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;store+ with the 2 bit memory index encoded in the store+ instruction.<br/>
  <h2><a name=".store-">.store-</a></h2>
    <b>Description:</b>  Generate the <tt>store-</tt> instruction.<br/><br/>
    <b>Operation:</b>  <tt>.store-(ram)</tt> generates the following instruction:<br/>
      &nbsp;&nbsp;1&nbsp;&mdash;&nbsp;store- with the 2 bit memory index encoded in the store- instruction.<br/>
  <h2><a name=".storeindexed">.storeindexed</a></h2>
    TODO
  <h2><a name=".storevalue">.storevalue</a></h2>
    TODO
  <h2><a name=".storevector">.storevector</a></h2>
    TODO
</body>
</html>
