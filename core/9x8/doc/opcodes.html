
<!-- Copyright 2012, Sinclair R.F., Inc. -->
<html>
<title>
Opcodes
</title>
<body>
<h1>Opcodes for the 9x8 micro controller</h1><br/>
Copyright 2012, Sinclair R.F., Inc.<br/><br/>
This document describes the opcodes for the 9x8 micro controller.  The first
  section lists the opcodes in alphabetic order, the second lists them by their
  numerical value, and the final section describes each one in detail.<br/><br/>
Some of the opcodes are not directly accessible by the assembler and must be
  accessed through macros.  See <a href="macros.html">macros</a> for
  documentation on accessing these opcodes.  Other opcodes can be directly
  accessed or can be accessed through a macro.<br/><br/>
<h1>OPCODES</h1>
  This section documents the opcodes.<br/><br/>
  Alphabetic listing:
    <a href="#&">&amp;</a>,
    <a href="#+">+</a>,
    <a href="#-">-</a>,
    <a href="#-1<>">-1&lt;&gt;</a>,
    <a href="#-1=">-1=</a>,
    <a href="#0<>">0&lt;&gt;</a>,
    <a href="#0=">0=</a>,
    <a href="#0>>">0&gt;&gt;</a>,
    <a href="#1+">1+&gt;</a>,
    <a href="#1-">1-&gt;</a>,
    <a href="#1>>">1&gt;&gt;</a>,
    <a href="#<<0">&lt;&lt;0</a>,
    <a href="#<<1">&lt;&lt;1</a>,
    <a href="#<<msb">&lt;&lt;msb</a>,
    <a href="#>r">&gt;r</a>,
    <a href="#^">^</a>,
    <a href="#call">call</a>,
    <a href="#callc">callc</a>,
    <a href="#drop">drop</a>,
    <a href="#dup">dup</a>,
    <a href="#fetch">fetch</a>,
    <a href="#fetch+">fetch+</a>,
    <a href="#fetch-">fetch-</a>,
    <a href="#inport">inport</a>,
    <a href="#jump">jump</a>,
    <a href="#jumpc">jumpc</a>,
    <a href="#lsb>>">lsb&gt;&gt;</a>,
    <a href="#msb>>">msb&gt;&gt;</a>,
    <a href="#nip">nip</a>,
    <a href="#nop">nop</a>,
    <a href="#or">or</a>,
    <a href="#outport">outport</a>,
    <a href="#over">over</a>,
    <a href="#push">push</a>,
    <a href="#r>">r&gt;</a>,
    <a href="#r@">r@</a>,
    <a href="#return">return</a>,
    <a href="#store">store</a>,
    <a href="#store+">store+</a>,
    <a href="#store-">store-</a>,
    <a href="#swap">swap</a>
    <br/><br/>
<h1><a name="opcode_mapping">Opcode Mapping</a></h1>
  <table>
  <tr>
    <th align="left">Opcode&nbsp;&nbsp;&nbsp;</th>
      <th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3&nbsp;&nbsp;&nbsp;</th><th>2</th><th>1</th><th>0&nbsp;&nbsp;&nbsp;</th>
      <th align="left">Description</th>
      </tr>
    <th align="left"><a href="#nop">nop</a></th>
      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
      <td align="left">no operation</td>
      </tr>
    <th align="left"><a href="#<<0">&lt;&lt;0</a></th>
      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td>
      <td align="left">left shift 1 bit and bring in a 0</td>
      </tr>
    <th align="left"><a href="#<<1">&lt;&lt;1</a></th>
      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td>
      <td align="left">left shift 1 bit and bring in a 1</td>
      </tr>
    <th align="left"><a href="#<<msb">&lt;&lt;msb</a></th>
      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td>
      <td align="left">left shift 1 bit and rotate the msb into the lsb</td>
      </tr>
    <th align="left"><a href="#0>>">0&gt;&gt;</a></th>
      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td>
      <td align="left">right shift 1 bit and bring in a 0</td>
      </tr>
    <th align="left"><a href="#1>>">1&gt;&gt;</a></th>
      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td>
      <td align="left">right shift 1 bit and bring in a 1</td>
      </tr>
    <th align="left"><a href="#msb>>">msb&gt;&gt;</a></th>
      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td>
      <td align="left">right shift 1 bit and keep the msb the same</td>
      </tr>
    <th align="left"><a href="#lsb>>">lsb&gt;&gt;</a></th>
      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td>
      <td align="left">right shift 1 bit and rotate the lsb into the msb</td>
      </tr>
    <th align="left"><a href="#dup">dup</a></th>
      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td>
      <td align="left">push a duplicate of the top of the data stack onto the data stack</td>
      </tr>
    <th align="left"><a href="#r@">r@</a></th>
      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td>
      <td align="left">push a duplicate of the top of the return stack onto the data stack</td>
      </tr>
    <th align="left"><a href="#over">over</a></th>
      <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td>
      <td align="left">push a duplicate of the next-to-top of the data stack onto the data stack</td>
      </tr>
    <th align="left"><a href="#swap">swap</a></th>
      <td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td>
      <td align="left">swap the top and the next-to-top of the data stack</td>
      </tr>
    <th align="left"><a href="#+">+</a></th>
      <td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td>
      <td align="left">pop the stack and replace the top with N+T</td>
      </tr>
    <th align="left"><a href="#-">-</a></th>
      <td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td>
      <td align="left">pop the stack and replace the top with N-T</td>
      </tr>
    <th align="left"><a href="#0=">0=</a></th>
      <td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
      <td align="left">replace the top of the stack with "<tt>0xFF</tt>" if it is "<tt>0x00</tt>" (i.e., it is zero), otherwise replace it with "<tt>0x00</tt>"<br/>
      </tr>
    <th align="left"><a href="#0<>">0&lt;&gt;</a></th>
      <td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td>
      <td align="left">replace the top of the stack with "<tt>0xFF</tt>" if it is not "<tt>0x00</tt>" (i.e., it is non-zero), otherwise replace it with "<tt>0x00</tt>"<br/>
      </tr>
    <th align="left"><a href="#-1=">-1=</a></th>
      <td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td>
      <td align="left">replace the top of the stack with "<tt>0xFF</tt>" if it is "<tt>0xFF</tt>" (i.e., it is all ones), otherwise replace it with "<tt>0x00</tt>"<br/>
      </tr>
    <th align="left"><a href="#-1<>">-1&lt;&gt;</a></th>
      <td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td>
      <td align="left">replace the top of the stack with "<tt>0xFF</tt>" if it is not "<tt>0xFF</tt>" (i.e., it is not all ones), otherwise replace it with "<tt>0x00</tt>"<br/>
      </tr>
    <th align="left"><a href="#return">return</a></th>
      <td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td>
      <td align="left">return from a function call</td>
      </tr>
    <th align="left"><a href="#inport">inport</a></th>
      <td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td>
      <td align="left">replace the top of the stack with the contents of the specified input port</td>
      </tr>
    <th align="left"><a href="#outport">outport</a></th>
      <td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td>
      <td align="left">write the next-to-top of the data stack to the output port specified by the top of the data stack</td>
      </tr>
    <th align="left"><a href="#>r">&gt;r</a></th>
      <td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
      <td align="left">Pop the top of the data stack and push it onto the return stack</td>
      </tr>
    <th align="left"><a href="#r>">r&gt;</a></th>
      <td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td>
      <td align="left">Pop the top of the return stack and push it onto the data stack</td>
      </tr>
    <th align="left"><a href="#&">&amp;</a></th>
      <td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td>
      <td align="left">pop the stack and replace the top with N &amp; T</td>
      </tr>
    <th align="left"><a href="#or">or</a></th>
      <td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td>
      <td align="left">pop the stack and replace the top with N | T</td>
      </tr>
    <th align="left"><a href="#^">^</a></th>
      <td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td>
      <td align="left">pop the stack and replace the top with N ^ T</td>
      </tr>
    <th align="left"><a href="#nip">nip</a></th>
      <td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td>
      <td align="left">pop the next-to-top from the data stack</td>
      </tr>
    <th align="left"><a href="#drop">drop</a></th>
      <td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td>
      <td align="left">drop the top value from the stack<tt></td>
      </tr>
    <th align="left"><a href="#1+">1+</a></th>
      <td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td>
      <td align="left">Add 1 to T</td>
      </tr>
    <th align="left"><a href="#1-">1-</a></th>
      <td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td>
      <td align="left">Subtract 1 from T</td>
      </tr>
    <th align="left"><a href="#store">store</a></th>
      <td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>b</td><td>b</td>
      <td align="left">Store N in the T'th entry in bank "<tt>bb</tt>", drop the top of the data stack</td>
      </tr>
    <th align="left"><a href="#fetch">fetch</a></th>
      <td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>b</td><td>b</td>
      <td align="left">Exchange the top of the stack with the T'th value from bank "<tt>bb</tt>"</td>
      </tr>
    <th align="left"><a href="#store+">store+</a></th>
      <td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>b</td><td>b</td>
      <td align="left">Store N in the T'th entry in bank "<tt>bb</tt>", nip the data stack, and increment T</td>
      </tr>
    <th align="left"><a href="#store-">store-</a></th>
      <td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>b</td><td>b</td>
      <td align="left">Store N in the T'th entry in bank "<tt>bb</tt>", nip the data stack, and decrement T</td>
      </tr>
    <th align="left"><a href="#fetch+">fetch+</a></th>
      <td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>b</td><td>b</td>
      <td align="left">Push the T'th entry from bank "<tt>bb</tt>" into the data stack as N and increment T</td>
      </tr>
    <th align="left"><a href="#fetch-">fetch-</a></th>
      <td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>b</td><td>b</td>
      <td align="left">Push the T'th entry from bank "<tt>bb</tt>" into the data stack as N and decrement T</td>
      </tr>
    <th align="left"><a href="#jump">jump</a></th>
      <td>0</td><td>1</td><td>0</td><td>0</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td>
      <td align="left">Jump to the address "<tt>x_xxxx_TTTT_TTTT</tt>"</td>
      </tr>
    <th align="left"><a href="#jumpc">jumpc</a></th>
      <td>0</td><td>1</td><td>0</td><td>1</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td>
      <td align="left">Conditionally jump to the address "<tt>x_xxxx_TTTT_TTTT</tt>"</td>
      </tr>
    <th align="left"><a href="#call">call</a></th>
      <td>0</td><td>1</td><td>1</td><td>0</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td>
      <td align="left">Call the function at address "<tt>x_xxxx_TTTT_TTTT</tt>"</td>
      </tr>
    <th align="left"><a href="#callc">callc</a></th>
      <td>0</td><td>1</td><td>1</td><td>1</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td>
      <td align="left">Conditionally call the function at address "<tt>x_xxxx_TTTT_TTTT</tt>"</td>
      </tr>
    <th align="left"><a href="#push">push</a></th>
      <td>1</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td>
      <td align="left">Push the 8-bit value "<tt>xxxx_xxxx</tt>" onto the data stack.</td>
      </tr>
  </table>
<h1>Detailed Descriptions</h1>
  <h2><a name="&">Instruction:  &amp;</a></h2>
    <b>Desription:</b>  Pop the data stack and replace the top with the bitwise
      and of the previous top and next-to-top.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; T &amp; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="+">Instruction:  +</a></h2>
    <b>Desription:</b>  Pop the data stack and replace the top with the
      8&nbsp;sum of the previous top and next-to-top.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N + T<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="-">Instruction:  -</a></h2>
    <b>Desription:</b>  Pop the data stack and replace the top with the
      8&nbsp;difference of the previous top and next-to-top.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N - T<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="-1<>">Instruction:  -1<></a></h2>
    <b>Desription:</b>  Set the top of the stack to all ones if the previous
      value was not all ones, otherwise set it to all zeros.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; 0xFF if T!=0xFF, 0x00 otherwise<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="-1=">Instruction:  -1=</a></h2>
    <b>Desription:</b>  Set the top of the stack to all ones if the previous
      value was all ones, otherwise set it to all zeros.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; 0xFF if T=0xFF, 0x00 otherwise<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="0<>">Instruction:  0<></a></h2>
    <b>Desription:</b>  Set the top of the stack to all ones if the previous
      value was not all zeros, otherwise set it to all zeros.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; 0xFF if T!=0x00, 0x00 otherwise<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="0=">Instruction:  0=</a></h2>
    <b>Desription:</b>  Set the top of the stack to all ones if the previous
      value was all zeros, otherwise set it to all zeros.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; 0xFF if T=0x00, 0x00 otherwise<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="0>>">Instruction:  0&gt;&gt;</a></h2>
    <b>Desription:</b>  Right shift the top of the stack one bit, replacing the
      left-most bit with a zero.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; { 0, T[7], T[6], ..., T[1] }<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="1+">Instruction:  1+</a></h2>
    <b>Desription:</b>  Add 1 to T.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; T+1<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="1-">Instruction:  1-</a></h2>
    <b>Desription:</b>  Subtract 1 from T.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; T-1<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="1>>">Instruction:  1&gt;&gt;</a></h2>
    <b>Desription:</b>  Right shift the top of the stack one bit, replacing the
      left-most bit with a zero.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; { 1, T[7], T[6], ..., T[1] }<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="<<0">Instruction:  &lt;&lt;0</a></h2>
    <b>Desription:</b>  Left shift the top of the stack one bit, replacing the
      right-most bit with a zero.
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; { T[6], T[5], ..., T[0], 0 }<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="<<1">Instruction:  &lt;&lt;1</a></h2>
    <b>Desription:</b>  Left shift the top of the stack one bit, replacing the
      right-most bit with a one.<br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; { T[6], T[5], ..., T[0], 1 }<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="<<msb">Instruction:  &lt;&lt;msb</a></h2>
    <b>Desription:</b>  Left shift the top of the stack one bit, leaving the
      right-most bit unchanged.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; { T[6], T[5], ..., T[0], T[7] }<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name=">r">Instruction:  &gt;r</a></h2>
    <b>Desription:</b>  Pop the data stack and push its previous value onto the
      return stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R &leftarrow; T<br/>
      <tt>++return</tt> &leftarrow; R<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="^">Instruction:  ^</a></h2>
    <b>Desription:</b>  Pop the data stack and replace the top with the bitwise
      exclusive or of the previous top and next-to-top.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; T ^ N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="call">Instruction:  call</a></h2>
    <b>Desription:</b>  Call the function at the address constructed from the
      opcode and <tt>T</tt>.  Discard&nbsp;<tt>T</tt> and push the PC onto the
      return stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; { O[4], ..., O[0], T[7], T[6], ..., T[0] }<br/>
      R &leftarrow; PC+1<br/>
      <tt>++return</tt> &leftarrow; R<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
    <b>Special:</b><br/><br/>
      Interrupts are disabled during the clock cycle immediately following a
      call instruction.<br/><br/>
      The assembler normally places a "<tt>nop</tt>" instruction immediately
      after the "<tt>call</tt>" instruction.<br/><br/>
  <h2><a name="callc">Instruction:  callc</a></h2>
    <b>Desription:</b>  Conditionally call the function at the address
      constructed from the opcode and <tt>T</tt>.  Discard&nbsp;<tt>T</tt> and
      conditionally push the next PC onto the return stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      if N != 0 then<br/>
      &nbsp;&nbsp;PC &leftarrow; { O[4], ..., O[0], T[7], T[6], ..., T[0] }<br/>
      &nbsp;&nbsp;R &leftarrow; PC<br/>
      &nbsp;&nbsp;<tt>++return</tt> &leftarrow; R<br/>
      else<br/>
      &nbsp;&nbsp;PC &leftarrow; PC+1<br/>
      &nbsp;&nbsp;R and <tt>return</tt> unchanged<br/>
      endif<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
    <b>Special:</b><br/><br/>
      Interrupts are disabled during the clock cycle immediately following a
      callc instruction.<br/><br/>
      The assembler normally places a "<tt>drop</tt>" instruction immediately
      after the "<tt>callc</tt>" instruction.<br/><br/>
  <h2><a name="drop">Instruction:  drop</a></h2>
    <b>Desription:</b>  Pop the data stack, discarding the value that had been
      on the top.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="dup">Instruction:  dup</a></h2>
    <b>Desription:</b>  Push the top of the data stack onto the data
      stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; T<br/>
      N &leftarrow; T<br/>
      <tt>++stack</tt> &leftarrow; N<br/>
      <br/>
  <h2><a name="fetch">Instruction:  fetch</a></h2>
    <b>Desription:</b>  Replace the top of the data stack with an 8&nbsp;bit
      value from memory.  The memory bank is specified by the two
      least-significant bits of the opcode.  The index within the memory bank is
      specified by the previous value of the top of the stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; bb[T] where "bb" is the bank<br/>
      N and <tt>stack</tt> unchanged<br/>
    <b>Special:</b>
      See <a href="#memory">memory</a> for instructions on using the fetch and
      vectorized fetch macros.<br/>
      <br/>
  <h2><a name="fetch+">Instruction:  fetch+</a></h2>
    <b>Desription:</b>  Push the T'th entry from bank "<tt>bb</tt>" onto the
      data stack as N and increment the top of the data stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; T+1<br/>
      N &leftarrow; bb[T] where "bb" is the bank<br/>
      <tt>++stack</tt><br/>
    <b>Special:</b>
      See <a href="#memory">memory</a> for instructions on using the fetch and
      vectorized fetch macros.<br/>
      <br/>
  <h2><a name="fetch-">Instruction:  fetch-</a></h2>
    <b>Desription:</b>  Push the T'th entry from bank "<tt>bb</tt>" onto the
      data stack as N and decrement the top of the data stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; T-1<br/>
      N &leftarrow; bb[T] where "bb" is the bank<br/>
      <tt>++stack</tt><br/>
    <b>Special:</b>
      See <a href="#memory">memory</a> for instructions on using the fetch and
      vectorized fetch macros.<br/>
      <br/>
  <h2><a name="inport">Instruction:  inport</a></h2>
    <b>Desription:</b>  Replace the top of the data stack with the 8&nbsp;value
      from the port specified by the previous value of the top of the data
      stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; <tt>input_port</tt>[T]<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
    <b>Special:</b><br/><br/>
      The recommended procedure to read from an inport port is to use the
      "<tt>.inport</tt>" macro.<br/><br/>
  <h2><a name="jump">Instruction:  jump</a></h2>
    <b>Desription:</b>  Jump to the address constructed from the opcode and
      <tt>T</tt>.  Discard&nbsp;<tt>T</tt>.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; { O[4], ..., O[0], T[7], T[6], ..., T[0] }<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
    <b>Special:</b><br/><br/>
      Interrupts are disabled during the clock cycle immediately following a
      jump instruction.<br/><br/>
      The assembler normally places a "<tt>nop</tt>" instruction immediately
      after the "<tt>jump</tt>" instruction.<br/><br/>
  <h2><a name="jumpc">Instruction:  jumpc</a></h2>
    <b>Desription:</b>  Jump to the address constructed from the opcode and
      <tt>T</tt> if <tt>N</tt> is non-zero.  Discard <tt>S</tt>
      and&nbsp;<tt>N</tt>.<br/><br/>
    <b>Operation:</b><br/><br/>
      if N != 0 then<br/>
      &nbsp;&nbsp;PC &leftarrow; { O[4], ..., O[0], T[7], T[6], ..., T[0] }<br/>
      else<br/>
      &nbsp;&nbsp;PC &leftarrow; PC+1<br/>
      end if<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
    <b>Special:</b><br/><br/>
      Interrupts are disabled during the clock cycle immediately following a
      jumpc instruction.<br/><br/>
      The assembler normally places a "<tt>drop</tt>" instruction immediately
      after the "<tt>jump</tt>" instruction so that the conditional is dropped
      from the data stack.<br/><br/>
  <h2><a name="lsb>>">Instruction:  lsb&gt;&gt;</a></h2>
    <b>Desription:</b>  Right shift the top of the stack one bit, replacing the
      left-most bit with the previous value of the right-most bit.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; { T[0], T[7], T[6], ..., T[1] }<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="msb>>">Instruction:  msb&gt;&gt;</a></h2>
    <b>Desription:</b>  Right shift the top of the stack one bit, preserving the
      value of the left-most bit.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; { T[7], T[7], T[6], ..., T[1] }<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="nip">Instruction:  nip</a></h2>
    <b>Desription:</b>  Discard the next-to-top value on the data
      stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <return</tt> unchanged<br/>
      T &leftarrow; T<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="nop">Instruction:  nop</a></h2>
    <b>Desription:</b>  No operation.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow PC + 1<br/>
      R, <tt>return</tt>, T, N, and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="or">Instruction:  or</a></h2>
    <b>Desription:</b>  Pop the data stack and replace the top with the bitwise
      or of the previous top and next-to-top.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; T or N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="outport">Instruction:  outport</a></h2>
    <b>Desription:</b>  Pop the data stack and write the previous next-to-top to
      the port specified by the previous top.<br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <tt>outport</tt>[T] &leftarrow; N<br/>
      <br/>
    <b>Special:</b><br/><br/>
      This instruction must be following by a "<tt>drop</tt>" in order to
      discard the value from the data stack that had been written to the data
      port.  The recommended procedure to write to an output port is to use the
      "<tt>.outport</tt>" macro.<br/><br/>
  <h2><a name="over">Instruction:  over</a></h2>
    <b>Desription:</b>  Push the next-to-top of the data stack onto the data
      stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N<br/>
      N &leftarrow; T<br/>
      <tt>++stack</tt> &leftarrow; N<br/>
      <br/>
  <h2><a name="push">Instruction:  push</a></h2>
    <b>Description:</b>  Push the specified 8-bit value onto the 8-bit
      stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; <tt>opcode</tt>[7:0]<br/>
      N &leftarrow; T<br/>
      <tt>++stack</tt> &leftarrow; N<br/>
      <br/>
  <h2><a name="r>">Instruction:  r&gt;</a></h2>
    <b>Desription:</b>  Pop the return stack and push its previous value onto
      the data stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R &leftarrow; <tt>return--</tt><br/>
      T &leftarrow; R<br/>
      N &leftarrow; T<br/>
      <tt>++stack</tt> &leftarrow; N<br/>
      <br/>
  <h2><a name="r@">Instruction:  r@</a></h2>
    <b>Desription:</b>  Push the top of the return stack onto the data
      stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; R<br/>
      N &leftarrow; T<br/>
      <tt>++stack</tt> &leftarrow; N<br/>
  <h2><a name="return">Instruction:  return</a></h2>
    <b>Description:</b>  Popd the top of the return stack into the PC.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; R<br/>
      R &leftarrow; <tt>return--</tt><br/>
      T, N, and <tt>stack</tt> unchanged<br/>
      <br/>
    <b>Special:</b>
      This instruction must be followed by a "<tt>nop</tt>"
      instruction.<br/><br/>
  <h2><a name="store">Instruction:  store</a></h2>
    <b>Desription:</b>  Drop the top of the data stack and store the previous
      next-to-top of the data stack at the memory location specified by the top
      of the data stack.  The memory bank is specified by the two least
      significant bits of the opcode.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      bb[T] &leftarrow; N where "<tt>bb</tt>" is the bank<br/>
      <br/>
    <b>Special:</b>
      See <a href="#memory">memory</a> for instructions on using the store and
      vectorized store macros.<br/>
      <br/>
  <h2><a name="store+">Instruction:  store+</a></h2>
    <b>Desription:</b>  Nip the data stack and store the previous next-to-top of
      the data stack at the memory location specified by the top of the data
      stack.  Increment the top of the data stack  The memory bank is specified
      by the two least significant bits of the opcode.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; T+1<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      bb[T] &leftarrow; N where "<tt>bb</tt>" is the bank<br/>
      <br/>
    <b>Special:</b>
      See <a href="#memory">memory</a> for instructions on using the store and
      vectorized store macros.<br/>
      <br/>
  <h2><a name="store-">Instruction:  store-</a></h2>
    <b>Desription:</b>  Nip the data stack and store the previous next-to-top of
      the data stack at the memory location specified by the top of the data
      stack.  Decrement the top of the data stack  The memory bank is specified
      by the two least significant bits of the opcode.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; T-1<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      bb[T] &leftarrow; N where "<tt>bb</tt>" is the bank<br/>
      <br/>
    <b>Special:</b>
      See <a href="#memory">memory</a> for instructions on using the store and
      vectorized store macros.<br/>
      <br/>
  <h2><a name="swap">Instruction:  swap</a></h2>
    <b>Desription:</b>  Swap the top two values on the data stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N<br/>
      N &leftarrow; T<br/>
      <tt>stack</tt> unchanged<br/>
      <br/>
</body>
</html>
